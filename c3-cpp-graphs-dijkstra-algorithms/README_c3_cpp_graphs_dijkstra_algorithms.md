# ğŸ§® C++ Graphs, Algorithms & STL Simulations  
**Folder**: `c3-cpp-graphs-dijkstras-algorithms`  
**Focus**: C++-based graph simulation, STL containers, file-driven logic, and algorithm design under pressure

â¸»

## ğŸ¯ Overview  
This project marked my transition from procedural C into structured and simulation-ready C++. I explored C++'s power through **vectors**, **sets**, **templates**, and **graph logic**, learning how to model real-world problems using modern containers and modular design patterns.

By blending algorithm design with STL workflows and simulation-driven thinking, I leveled up my ability to write efficient, scalable, and justifiable codeâ€”especially for systems and logic-heavy environments.

Key topics explored:
- STL syntax mastery: `vector`, `set`, iterators, `.begin()`, `.push_back()`, etc.  
- Graph logic via adjacency matrices, Dijkstraâ€™s algorithm, and minimum spanning trees  
- Simulation thinking using the `<random>` library for controlled probabilistic behavior  
- File-driven input/output and matrix parsing for external datasets  
- Modular planning using pseudocode and breakdowns before implementation  
- Just-in-time reasoning under time pressure for logic exams

â¸»

## ğŸ› ï¸ Featured Tasks  

âœ… Translated a procedural C program into modular C++  
âœ… Simulated shortest-path traversal using Dijkstraâ€™s algorithm  
âœ… Parsed graph data from `.txt` files and built MSTs using Primâ€™s logic  
âœ… Practiced STL usage with logic-driven exam prompts  
âœ… Justified code logic, performance tradeoffs, and abstractions in written form  
âœ… Scored a perfect 100% on the logic-based final exam

ğŸ§  Each subfolder (`m1`â€“`m5`) includes:
- Planning breakdowns and pseudocode  
- Final `.cpp` implementations  
- Output validation and reasoning  
- Exam-style questions with deep logic writeups

â¸»

## ğŸ’¡ Reflection  
This project taught me how to **think like a C++ developer**. I moved from syntax memorization into design-level thinkingâ€”understanding how abstraction, STL patterns, and modular structure turn C++ into a creative tool for simulation and logic-heavy work.

The simulation modules especially clicked with my background in systems and XR environments. It showed me how C++ can model probability, simulate paths, and structure decision logicâ€”a perfect foundation for game mechanics, training simulations, and scientific modeling going forward.

C++ became less of a wall and more of a **scaffold**â€”something I could now wield to build powerful, data-aware systems with clarity and control.
