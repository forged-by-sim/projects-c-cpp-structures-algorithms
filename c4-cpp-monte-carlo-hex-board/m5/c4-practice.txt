1. What is the C++11 meaning of the term &&?
==> Move semantics


2. What is the C++11 meaning of the term nullptr?
==> Pointer to 0


3. What is the C++11 meaning of the term auto?
==> Infer type


4. What is the C++11 meaning of the term explicit?
==> Disable automatic conversion


5. What is the C++11 meaning of the term noexcept?
==> No exceptions thrown


6. The header <future> in C++11 is used for:
==> Concurrency


7. L. Euler invented:
==> Graph theory


8. D. Knuth analyzed or invented:
==> Alpha-beta


9. A new keyword in C++11 is:
==> nullptr


10. A try block in C++:
==> Is a scope that is followed by catch expressions


11. C++11 STL:
==> Has a hash based map


12. HEX as a graph has its internal nodes:
==> With degree 6


13. True or False: When you rethrow an exception, its type and value is convertible to int.
==> False


14. True or False: Overloaded operators are always defined using static functions.
==> False


15. True or False: All exceptions in C++ have as their base type std::exception.
==> False


16. True or False: Writeln is a new keyword in C++11.
==> False


17. True or False: In f(1) || (!g(2)), f(1) will always be evaluated before g(2) (which may not get evaluated).
==> True


18. Using alpha-beta, can any LEAF nodes not be evaluated in the above tree?
==> Yes


19. When using =0 as the body of a function you are:
==> An abstract base class


20. The catch signature ... means:
==> Match any type




Code:

list<int> data = {0, 2, 5, 7, 9};
auto foobar = data.begin();
for (; foobar != data.end(); )
    if (*foobar % 2 == 1)
        foobar = data.erase(foobar);
    else
        ++foobar;


21. In the following code segment, the type of foobar is:
==> list<int>::iterator


22. In the following code, the list will end up:
==> Having 2 elements





Given tree structure
                      Max
                     /   \
                 Min       Min
                /   \     /   \
              Max   Max  Max  Max
             / \   / \  / \   / \
           15  6  7 13  3  5 24  8


Leaf Nodes: 15, 6, 7, 13, 3, 5, 24, 8

23. For the above tree, what are the four Max values on the ply above the leaf nodes (from left to right). (Enter the 4 Max values as they appear, left to right, with a space separating them. For example, if your answers are 1, 2, 3 and 4, you would enter: 1 2 3 4.)

==> 15 13 5 24


24. For the above tree, what are the two Min values on the second ply (from left to right)? (Enter the 2 Min values as they appear, left to right, with a space separating them. For example, if your answers are 1 and 2, you would enter: 1 2.)

==> 13 5

25. What is the Max value for the root of the tree?
==> 13


26. In the above tree, what is one of the two leaf node values that need not have been evaluated, using alpha-beta? (Enter one of the two possible values.)
==> 8




Given code (completed properly):
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int data[5] = {1, 7, 46, 9, 6};
    vector<int> data_vec(data, data + 5);
    int modulus = 3;

    // use of lambdas for predicates in find_if
    auto q = find_if(data_vec.begin(), data_vec.end(),
                     [modulus](int x) { return x % modulus == 0; });
    cout << "first *q = " << *q << endl;

    q = find_if(++q, data_vec.end(),
                [modulus](int x) { return x % modulus == 0; });
    cout << "second *q = " << *q << endl;
}



27. What does the following print for the first *q?
==>  9


28. What does the following print for the second *q?
==> 1



Full Code
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    vector<int> data(5, 1);
    int sum {0};

    cout << sum << endl;   // (Q29)

    for (auto element : data)    // (Q30–?)
    {
        sum += element;
        cout << sum << endl;
    }

    for (auto p = ++data.begin(); p != --data.end(); ++p)
    {
        sum += *p;
        cout << sum << endl;
    }

    sum = 0;
    data.push_back(2);
    data.push_back(3);

    for (auto element : data)
    {
        sum += element;
        cout << sum << endl;
    }

    cout << accumulate(data.begin(), data.end(), data[0]) << endl;
}




29. What does the first line of the following print?
==> 0


30. The key purpose of move semantics in C++11 is to improve efficiency by allowing resources (like dynamically allocated memory) to be transferred (“moved”) from one object to another without expensive deep copies.
==> efficiency


31. What does the second line of the following print? 
==> 2


32. What does the third line of the following print?
==> 3


33. What does the fourth line of the following print?
==> 4


34. What does the fifth line of the following print?
==> 5


 

Code:
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void speak() = 0; 
    virtual void purr() { cout << "Purr\n"; } 
};

class Cat : public Animal {
public:
    void speak() override { 
        cout << "Meow\n"; 
        purr(); 
    }
};

class Lion : public Cat {
public:
    void speak() override { cout << "ROAR\n"; } 
    void purr() override { cout << "ROAR\n"; }  
};

int main() {
    Animal* c = new Cat(); 
    Cat napster;
    Lion googly;

    c->speak();        
    napster.speak();   
    googly.speak();    

    return 0;
}



35. What does the first line of the following print?
==> Meow


36. What does the second line of the following print?
==> Purr


37. What does the third line of the following print?
==> Meow


38. What does the fourth line of the following print?
==> Purr


39. What does the fifth line of the following print?
==> ROAR


40. The safest cast in C++ is considered:
==> static_cast


41. The MST for an undirected connected graph of N nodes where all weights are cost C has:
==> A value of (N − 1) × C


42. True or false? Overloaded operators are always defined using static functions.
==> False

