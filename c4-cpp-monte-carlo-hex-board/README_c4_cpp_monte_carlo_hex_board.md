# ğŸ¯ C++ Simulation Design: Monte Carlo Hex & Intelligent Evaluation  
**Folder**: `c4-cpp-monte-carlo-hex-board`  
**Focus**: Designing simulation-based systems in C++ using graph structures, game logic, Monte Carlo evaluation, and STL-driven architecture

â¸»

## ğŸ§  Overview  
This project pushed my C++ design skills into **strategy, simulation, and systems thinking**. I moved beyond procedural logic and into the architecture of reusable, object-oriented codeâ€”blending graph algorithms with intelligent evaluation and Monte Carlo-based decision-making.

The central focus was building a playable **Hex game simulation**, from raw board logic to advanced AI techniques like Alpha-Beta pruning and expression tree parsing. Each task pushed me to write modular, clean C++ and simulate outcomes under uncertain or probabilistic conditions.

Key topics explored:
- Design with constructors, inheritance, and `std::move` semantics  
- Monte Carlo simulations for game state evaluation  
- Intelligent move selection using Min-Max and Alpha-Beta pruning  
- STL-based graph modeling using `vector`, `set`, and `pair`  
- Expression trees and prefix notation evaluation using abstract classes  
- Debugging game logic based on probability, performance, and class responsibility  

â¸»

## ğŸ› ï¸ Featured Tasks  

âœ… Constructed a Hex board from scratch using adjacency graph logic  
âœ… Designed a full game system with modular classes and decision tracking  
âœ… Built a Monte Carlo evaluator to simulate random outcomes and score moves  
âœ… Practiced move pruning with Alpha-Beta enhancements  
âœ… Parsed and evaluated expressions using tree-based inheritance structures  

ğŸ§ª Each subfolder (`m1`â€“`m5`) includes:
- Modular `.cpp` implementations  
- Planning notes, strategy breakdowns, and annotated design flows  
- Output validation, simulation logic, and internal exam reflections

â¸»

## ğŸ’¡ Reflection  
This was the project of my C++ transformationâ€”from writing lines of code to designing intelligent systems. I learned how to think like a **simulation engineer**, not just a developer. The Hex project gave me a safe yet complex space to experiment with risk-based evaluation, performance design, and STL architecture.

I found myself debugging game logic through probabilistic reasoningâ€”a sign that these tools had become internalized. Ending with these results wasnâ€™t just validationâ€”it was a signal that I could now simulate, scale, and solve like a C++ technologist.

This isnâ€™t just about a game. Itâ€™s about building systems that **reason**.
